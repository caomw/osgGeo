#ifndef OSGGEO_LAYEREDTEXTURE_H
#define OSGGEO_LAYEREDTEXTURE_H

/* osgGeo - A collection of geoscientific extensions to OpenSceneGraph.
Copyright 2011 dGB Beheer B.V.

osgGeo is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

#include <osg/Object>
#include <osg/Vec2f>
#include <OpenThreads/ReadWriteMutex>
#include <osgGeo/Common>
#include <vector>

namespace osg { class Geometry; class Vec4d; }

namespace osgGeo
{

class OSGGEO_EXPORT ColorSequence
{
public:
				ColorSequence();
    virtual			~ColorSequence();

    unsigned char*		getRGBAValues()		{ return arr_; }
    const unsigned char*	getRGBAValues() const	{ return arr_; }
    void			touch()			{ dirtycount_++; }
    unsigned int		getModifiedCount()	{ return dirtycount_; }

protected:
    unsigned char*		arr_;
    int				dirtycount_;
};

struct LayeredTextureData;
struct TilingInfo;

enum TransparencyType { Opaque, HasTransparencies, OnlyFullTransparencies };


class OSGGEO_EXPORT LayeredTexture : public osg::Object
{
public:
    class LayerProcess : public osg::Referenced
    {
	virtual const char*	getShaderSourceCode()		= 0;
	virtual bool		needsTextureRow() const		= 0;
	virtual void		setTexturePtr(unsigned char* rgba) {}
	virtual void		setTextureCoord(float)		{}

	virtual TransparencyType getTransparencyType(const LayeredTexture*) const;
	virtual bool		doProcess(const LayeredTexture*,
					  osg::Image* output)	= 0;
    };

			LayeredTexture();
			LayeredTexture(const LayeredTexture&,
			    const osg::CopyOp& op =osg::CopyOp::DEEP_COPY_ALL);

			META_Object( osgGeo, LayeredTexture );

    int			addDataLayer(); //returns an id
			//Does its own locking
    void		removeDataLayer(int id);
			//Does its own locking

    void		readLock() { _lock.readLock(); }
			//Protects the layers, not the contents of them
    void		readUnLock() { _lock.readUnlock(); }

    int			nrDataLayers() const { return _dataLayers.size(); }
    int			getDataLayerID(int idx) const;
    int			getDataLayerIndex(int id) const;

    void		setDataLayerImage(int id,const osg::Image*);
    const osg::Image*	getDataLayerImage(int id) const;

    osg::Vec2f		envelopeCenter() const;
    osg::Vec2f		envelopeSize() const;
    bool		needsRetiling() const;

    void		setDataLayerOrigin(int id,const osg::Vec2f&);
    const osg::Vec2f&	getDataLayerOrigin(int id) const;

    void		setDataLayerScale(int id,const osg::Vec2f&);
    const osg::Vec2f&	getDataLayerScale(int id) const;

    void		setDataLayerTextureUnit(int id,int unit);
    int			getDataLayerTextureUnit(int id) const;

    void		setDataLayerBorderColor(int id, const osg::Vec4d&);
    const osg::Vec4d&	getDataLayerBorderColor(int id) const;

    int			nrProcesses() const	   { return _processes.size(); }
    LayerProcess*	getProcess(int idx)	   { return _processes[idx]; }
    const LayerProcess*	getProcess(int idx) const  { return _processes[idx]; }

    void		addProcess(LayerProcess*);
			//Does its own locking
    void		removeProcess(const LayerProcess*);
			//Does its own locking
    void		moveProcessEarlier(const LayerProcess*);
			//Does its own locking
    void		moveProcessLater(const LayerProcess*);
			//Does its own locking

    struct		TextureCoordData
    {
			TextureCoordData(int tu,
				const osg::Vec2f& tc00, const osg::Vec2f& tc01,
				const osg::Vec2f& tc10, const osg::Vec2f& tc11 )
			    : _tc00( tc00 ), _tc01( tc01 )
			    , _tc10( tc10 ), _tc11( tc11 )
			    , _textureUnit( tu )
			{}

	int		_textureUnit;
	osg::Vec2f	_tc00, _tc01, _tc10, _tc11;
    };

    osg::StateSet*	getSetupStateSet();
    osg::StateSet*	createCutoutStateSet(const osg::Vec2f& origin,
			    const osg::Vec2f& opposite,
			    std::vector<TextureCoordData>&) const;

    void		planTiling(int brickSize,
			    std::vector<float>& xTickMarks,
			    std::vector<float>& yTickMarks) const;

    void		setMaxTextureCopySize(unsigned int width_x_height);
			/* The size of a non-power-of-2 texture layer will upper
			   bound the tile size. Therefore, a power-of-2 scaled
			   copy is created for small non-power-of-2 textures. */

    static unsigned int	getTextureSize(unsigned short nr);


protected:
			~LayeredTexture();
    void		updateSetupStateSet();
    void		updateTilingInfoIfNeeded() const;

    static void		divideAxis(float totalSize,
				   int brickSize,
				   std::vector<float>& tickMarks);


    OpenThreads::ReadWriteMutex		_lock;
    int					_freeId;
    std::vector<LayeredTextureData*>	_dataLayers;
    std::vector<LayerProcess*>		_processes;

    bool				_updateSetupStateSet;
    osg::ref_ptr<osg::StateSet>		_setupStateSet;

    unsigned int			_maxTextureCopySize;

    mutable TilingInfo*			_tilingInfo;
};


class OSGGEO_EXPORT ColTabLayerProcess : public LayeredTexture::LayerProcess
{
    void			setDataLayerID(int id);
    int				getDataLayerID() const;

    void			setDataLayerColorSequence(const ColorSequence*);
    const ColorSequence*	getLayerColorSequence() const;

    void			setDataLayerHasUndef(bool hasudf);
    bool			getDataLayerHasUndef() const;

    const char*			getShaderSourceCode() const;

    void			setTexturePtr(unsigned char* rgba);
    void			setTextureCoord(float);
    bool			needsTextureRow() const { return true; }
};


class OSGGEO_EXPORT RGBALayerProcess : public LayeredTexture::LayerProcess
{
public:
    void			setDataLayersID(int idx, int id);
				//int id=0 red
				//    id=1 green
				//    id=2 blue
				//    id=3 alpha
    int				getDataLayers(int idx) const;

    void			setDataLayerHasUndef(bool hasudf);
    bool			getDataLayerHasUndef() const;
    bool			needsTextureRow() const { return false; }
};

} //namespace

#endif //OSGGEO_LARGE_TEXTURE
