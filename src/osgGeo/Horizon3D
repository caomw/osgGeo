#ifndef OSGGEO_HORIZON3D_H
#define OSGGEO_HORIZON3D_H

/* osgGeo - A collection of geoscientific extensions to OpenSceneGraph.
Copyright 2011 dGB Beheer B.V.

osgGeo is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

#include <osgGeo/Horizon3DBase>

namespace osgGeo
{

class LayeredTexture;

class OSGGEO_EXPORT Horizon3DTileNode : public osg::Node
{
public:
    Horizon3DTileNode();
    Horizon3DTileNode(const Horizon3DTileNode &,
                      const osg::CopyOp& op =
            osg::CopyOp::DEEP_COPY_ALL);
    META_Node(osgGeo,Horizon3DTileNode)

    std::vector<osg::Vec2d> getCornerCoords() const;
    void setCornerCoords(const std::vector<osg::Vec2d> &coords);

    void setSize(const Vec2i &size);
    Vec2i getSize() const;

    virtual void traverse(osg::NodeVisitor& nv);
    void traverseSubNode(int lod, osg::NodeVisitor &nv);

    osg::Vec3 getCenter() const;

    void setNode(int resolution, osg::Node *node);
    void setPointLineNode(int resolution, osg::Node *node);

    virtual osg::BoundingSphere computeBound() const;
    void setBoundingSphere(const osg::BoundingSphere &boundingSphere);

    int hIdx, vIdx;

private:
    std::vector<osg::ref_ptr<osg::Node> > _nodes, _pointLineNodes;
    Vec2i _size;
    osg::Vec3 _center;
    std::vector<osg::Vec2d> _cornerCoords;
    osg::BoundingSphere _bs;
};


/**
  * Node to display a horizon object. Currently a simplistic
  * implementation that creates a single Geometry object
  * without breaking it into tiles. Normals are calculated
  * for each vertex, textures are not supported yet, currently
  * it is single coloured
  */
class OSGGEO_EXPORT Horizon3DNode : public Horizon3DBase
{
public:
    Horizon3DNode();
    Horizon3DNode(const Horizon3DNode&,
                  const osg::CopyOp& op =
                  osg::CopyOp::DEEP_COPY_ALL);
    META_Node(osgGeo,Horizon3DNode)

    void setLayeredTexture(LayeredTexture* texture);
    LayeredTexture* getLayeredTexture();
    const LayeredTexture* getLayeredTexture() const;

private:
    void init();

protected:
    void updateGeometry();
    osg::Image *makeElevationTexture();

    osg::ref_ptr<LayeredTexture> _texture;
};

}
#endif //OSGGEO_POLYLINE_H
